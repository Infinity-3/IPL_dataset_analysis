# -*- coding: utf-8 -*-
"""IPL dataset analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wV2LqzGmFg_Uf-Rd1AiaxceMLJkM0prP

## Summary:

### Q&A

**Q1: Basic Data Inspection**
*   Total number of matches: 756.
*   Number of columns: 18.
*   First 5 rows of the dataset were displayed.
*   Descriptive statistics for numerical columns were requested.

**Q2: Player of the Match**
*   All players who received the 'player_of_match' award were listed.

**Q3: Wankhede Stadium - Batting first vs. Batting second wins**
*   At Wankhede Stadium, it is more common to win by batting second (wickets).

**Q4: Team with most wins by over 50 runs**
*   Chennai Super Kings has the highest number of wins (13) where the victory margin was greater than 50 runs.

**Q5: Toss winner batting first and winning**
*   Total matches where the toss winner batted first and won: 132.
*   Team-wise breakdown: Chennai Super Kings: 30 times, Mumbai Indians: 24 times, etc.

**Q6: Umpires officiating KKR matches**
*   Both 'umpire1' and 'umpire2' positions officiated 178 matches each involving Kolkata Knight Riders.

**Q1 (Practice): Which team has won the most matches overall?**
*   Mumbai Indians with 109 matches.

**Q2 (Practice): Which team has lost the most tosses?**
*   Royal Challengers Bangalore with 99 tosses.

**Q3 (Practice): Which stadium has hosted the maximum number of matches?**
*   Eden Gardens with 77 matches.

**Q4 (Practice): Which year had the most total matches played?**
*   2013.

**Q5 (Practice): Which year saw the fewest total matches played?**
*   2009.

**Q6 (Practice): Which team has the most wins while chasing (result = wickets)?**
*   Kolkata Knight Riders.

**Q7 (Practice): Which team has the most wins while defending (result = runs)?**
*   Chennai Super Kings.

**Q8 (Practice): Which toss decision (bat/field) has resulted in more wins overall?**
*   Fielding/chasing team.

**Q9 (Practice): Which umpire has officiated the most matches overall?**
*   S Ravi.

**Q10 (Practice): Which city has hosted the maximum number of finals?**
*   Mumbai.

**Q11 (Practice): Which team has the highest average winning margin (by runs)?**
*   Royal Challengers Bangalore.

**Q12 (Practice): Which team has the most 1-run wins (closest finishes)?**
*   Mumbai Indians.

**Q13 (Practice): Which two teams have faced each other the most times?**
*   Chennai Super Kings vs Mumbai Indians, with 28 matches.

**Q14 (Practice): Which team has the most wins at their home ground?**
*   Mumbai Indians, with 53 wins.

**Q15 (Practice): Which season saw the highest number of matches decided by wickets (chasing wins)?**
*   IPL-2012.

**Q16 (Practice): Which toss-winning team chose to bat first most frequently?**
*   Chennai Super Kings.

**Q17 (Practice): Which team has the highest number of 'Player of the Match' awards in the dataset?**
*   Mumbai Indians.

**Q18 (Practice): Which team has the most matches that ended with no result?**
*   Royal Challengers Bangalore.

**Q19 (Practice): Which venue has hosted matches for the highest number of different teams?**
*   Eden Gardens.

**Q20 (Practice): Which team has the highest total number of matches played (either team1 or team2)?**
*   Mumbai Indians.

**Q21 (Practice): Which team has the lowest win percentage overall?**
*   Pune Warriors.

**Q22 (Practice): Which team won the very first IPL match in the dataset?**
*   Kolkata Knight Riders.

**Q23 (Practice): Which team won the most finals (championships) across all seasons?**
*   Mumbai Indians.

**Q24 (Practice): Which team won the least number of matches in the 2014 season?**
*   Delhi Daredevils.

**Q25 (Practice): Which team won the most matches in a single season?**
*   Rajasthan Royals.

**Q26 (Practice): Which toss-winning team most often chose to field first?**
*   Kolkata Knight Riders.

**Q27 (Practice): Which match had the largest victory margin by runs?**
*   Mumbai Indians defeated Delhi Daredevils by 146 runs in 2017.

**Q28 (Practice): Which match had the largest victory margin by wickets?**
*   Kolkata Knight Riders defeated Gujarat Lions by 10 wickets in 2017.

**Q29 (Practice): Which venue has hosted the fewest IPL matches ever?**
*   OUTsurance Oval, Bloemfontein.

**Q30 (Practice): Which year had the highest number of tied matches?**
*   IPL-2013.

**Q31 (Practice): Which team has the most tied matches in IPL history?**
*   Rajasthan Royals.

**Q32 (Practice): Which team has won most matches where they also lost the toss?**
*   Mumbai Indians.

**Q33 (Practice): Which team has won most matches played at Wankhede Stadium (excluding home advantage)?**
*   Mumbai Indians.

**Q34 (Practice): Which player has the highest number of Player of the Match awards overall?**
*   CH Gayle.

**Q35 (Practice): Which city has hosted matches in the most number of IPL seasons?**
*   Delhi.

**Q36 (Practice): Which umpire combination (umpire1 + umpire2 pair) appeared most frequently together?**
*   C Shamshuddin & S Ravi.

**Q37 (Practice): Which team won the most matches decided by exactly 6 wickets?**
*   Kings XI Punjab.

**Q38 (Practice): Which team has the highest total wins when the toss was lost but they batted first anyway?**
*   Chennai Super Kings.

**Q39 (Practice): Which team won the most matches by defending totals between 150–160 runs?**
*   Cannot be accurately answered with the current dataset due to lack of detailed score information. The analysis for wins by a run margin between 150-160 indicated 0 matches.

### Data Analysis Key Findings

*   **Dominant Teams:** Mumbai Indians consistently appear as a top team, leading in overall wins (109), most finals won, most 1-run wins, most home wins (53), and most matches played. Chennai Super Kings also show strong performance, with the most wins by >50 runs (13), most wins while defending, and most frequent choice to bat first after winning the toss.
*   **Toss Impact:** Batting second (chasing/winning by wickets) is generally more common for wins at Wankhede Stadium. Overall, the **Fielding/chasing team** has resulted in more wins than the Batting/defending team.
*   **Venue & Season Trends:** Eden Gardens has hosted the most matches (77) and the highest number of different teams. IPL-2013 had the most matches played and the highest number of tied matches, while 2009 saw the fewest matches.
*   **Player & Umpire Recognition:** CH Gayle holds the record for the most Player of the Match awards. Umpire S Ravi has officiated the most matches overall. The umpire pair of C Shamshuddin & S Ravi is the most frequent.
*   **Notable Extremes:** The largest victory margin by runs was 146 (Mumbai Indians in 2017), and by wickets was 10 (Kolkata Knight Riders in 2017). OUTsurance Oval, Bloemfontein, hosted the fewest IPL matches.
*   **Specific Team Performances:**
    *   Royal Challengers Bangalore has lost the most tosses (99) and been involved in the most no-result matches. They also have the highest average winning margin by runs.
    *   Pune Warriors have the lowest win percentage overall.
    *   Kings XI Punjab has the most wins decided by exactly 6 wickets.
*   **Data Limitation:** The dataset lacks specific run totals for each innings, preventing direct analysis of "defending totals between 150-160 runs." The current dataset only provides `win_by_runs` or `win_by_wickets` as victory margins.

### Insights or Next Steps

*   **Strategic Insights for Teams:** Given the strong correlation between batting second and winning at Wankhede Stadium, and the overall higher win rate for fielding-first teams, teams should strategically prioritize chasing targets, especially at specific venues like Wankhede.
*   **Enhance Dataset for Deeper Analysis:** To answer more granular questions, such as "defending totals between 150-160 runs," the dataset should be augmented with detailed scorecards including individual innings scores, fall of wickets, and overs bowled.
"""

import pandas as pd # Imports the pandas library, commonly used for data manipulation and analysis, and aliases it as `pd`.
import matplotlib.pyplot as plt # Imports the pyplot module from matplotlib, a popular library for creating static, interactive, and animated visualizations in Python, and aliases it as `plt`.
import seaborn as sns # Imports the seaborn library, which is built on matplotlib and provides a high-level interface for drawing attractive statistical graphics, and aliases it as `sns`.

data = pd.read_csv("ipl_dataset.csv") # Reads the 'ipl_dataset.csv' file into a pandas DataFrame named 'data'.

def list_dataframes():
    dataframes = {} # Initialize an empty dictionary to store DataFrame objects.
    for name, value in globals().items(): # Iterate through all global variables in the current environment.
        if isinstance(value, pd.DataFrame): # Check if the current global variable is a pandas DataFrame.
            dataframes[name] = value # If it is a DataFrame, add it to the 'dataframes' dictionary with its name as the key.

    if dataframes: # Check if any DataFrames were found.
        print("Available DataFrames:") # Print a header indicating the list of DataFrames.
        for name, df in dataframes.items(): # Iterate through the found DataFrames.
            print(f"- {name} (Shape: {df.shape})") # Print the name and shape of each DataFrame.
            display(df.head()) # Display the first 5 rows of each DataFrame for a preview.
    else: # If no DataFrames were found.
        print("No pandas DataFrames found in the current environment.") # Print a message indicating no DataFrames were found.

list_dataframes() # Call the function to execute it.

# # Q1
# print("Answer for question 1")

# # Total no of matches
# print('Total number of matches')
# print(data['team1'].count()) # Counts the number of non-null entries in the 'team1' column, representing total matches.

# # Column names
# print('Column names')
# print(data.columns) # Prints all column names in the DataFrame.

# # First 5 rows of data
# print("First 5 rows of data")
# print(data.head(5)) # Prints the first 5 rows of the DataFrame.

# # Describe the data
# print("Describe the data")
# print(data.describe) # Provides descriptive statistics of the DataFrame (e.g., count, mean, std, min, max).

# print()
# # Q2
# print("Answer for question 2")

# # player of the match
# print("player of the match")
# print(data['player_of_match']) # Prints the 'player_of_match' column, listing all players who received this award.

# print()
# # Q3
# print("Answer for question 3")

# # At Wankhede Stadium, is it more common to win by batting first (runs) or by batting second
# print('At Wankhede Stadium, is it more common to win by batting first (runs) or by batting second?')
# wankhede_df = data[data['venue'].str.contains("Wankhede", case=False, na=False)] # Filters the DataFrame to include only matches played at Wankhede Stadium.

# wins_by_runs = wankhede_df[(wankhede_df['result']=='normal') & (wankhede_df['win_by_runs'])].count() # Counts normal wins where a team won by runs (batting first).
# wins_by_wickets = wankhede_df[(wankhede_df['result']=='normal') & (wankhede_df['win_by_wickets'])].count() # Counts normal wins where a team won by wickets (batting second).
# if (wins_by_runs>wins_by_wickets) is True: print('At Wankhede Stadium, batting second (wickets) it is more common to win') # Compares wins by runs vs. wickets and prints the more common outcome.
# else: print('At Wankhede Stadium, batting first (runs) it is more common to win ')

# print()
# # Q4
# print('Answer for question 4')

# # Which team has the highest number of wins where the victory margin was greater than 50 runs
# print('Which team has the highest number of wins where the victory margin was greater than 50 runs')
# # if (data['win_by_runs']>50) is True: print(data['winner'].idxmax)
# big_win = data[(data['result']=='normal') & (data['win_by_runs']>50)] # Filters for normal matches won by more than 50 runs.
# team_wins = big_win['winner'].value_counts() # Counts the number of such wins for each team.
# top_team = team_wins.idxmax() # Gets the name of the team with the most such wins.
# top_team_wins = team_wins.max() # Gets the count of wins for that top team.
# print(f'{top_team} team has the {top_team_wins} number of wins where the victory margin was greater than 50 runs') # Prints the team and their win count.

# print()
# # Q5
# print('Answer for question 5')

# # How many times has the team that won the toss also set a target and won the match?
# print('How many times has the team that won the toss also set a target and won the match?')
# toss_winner = data[(data['toss_winner']==data['winner']) & (data['toss_decision']=='bat')& (data['result']=='normal')] # Filters for matches where toss winner is also match winner, chose to bat, and result was normal.
# teams_win_by_target = toss_winner['winner'].value_counts() # Counts such wins for each team.
# # print((teams_win_by_target))
# for i,j in teams_win_by_target.items(): # Iterates through the counts of wins per team.
#     print(f"{i}: {j} times") # Prints each team's name and their number of wins.
# print(f'Totally - {(toss_winner['winner']).count()} matches') # Prints the total number of such matches.

# print()
# # Q6
# print('Answer for question 6')

# # Which of the two umpires (umpire1 or umpire2) has officiated more matches involving the Kolkata Knight Riders?
# print('Which of the two umpires (umpire1 or umpire2) has officiated more matches involving the Kolkata Knight Riders?')
# kkr_matches = data[(data['team1']=='Kolkata Knight Riders') | (data['team2']=='Kolkata Knight Riders')] # Filters for matches involving Kolkata Knight Riders.
# umpire1 = kkr_matches['umpire1'].value_counts().count() # Counts unique umpires from 'umpire1' column in KKR matches.
# umpire2 = kkr_matches['umpire2'].value_counts().count() # Counts unique umpires from 'umpire2' column in KKR matches.
# print(umpire1,'-',umpire2) # Prints the counts of unique umpires.
# if int(umpire1)>int(umpire2): print('Umpire-1') # Compares the counts and prints which umpire has officiated more.
# else: print('Umpire-2')

# Some other pratice questions on this csv file
print('Some other pratice questions on this csv file')
print('1. Which team has won the most matches overall?') # Mumbai Indians
mostwin_teams = data['winner'].value_counts() # Counts the number of wins for each team and stores them in a Series.
print(f'{mostwin_teams.idxmax()} - {mostwin_teams.max()} matches') # Prints the team with the most wins and their total count.

# Which team has lost the most tosses?
print('2. Which team has lost the most tosses?') # Delhi Capitals (previously Delhi Daredevils)
tosswin_team = data['toss_winner'].value_counts() # Counts the number of tosses won by each team.
match_played = data['team1'].value_counts() + data['team2'].value_counts() # Calculates the total matches played by each team by summing their appearances as team1 and team2.
mostloss_toss_team = match_played - tosswin_team # Subtracts tosses won from total matches played to find tosses lost.
print(f'{mostloss_toss_team.idxmin()} - {mostloss_toss_team.min()} tosses') # Prints the team with the minimum (most) tosses lost and the count.
# print(mostloss_toss_team)

# Which stadium has hosted the maximum number of matches?
print('3. Which stadium has hosted the maximum number of matches?') # Eden Gardens, Kolkata
maxhost_stadium = data['venue'].value_counts() # Counts the occurrences of each venue to find how many matches each hosted.
print(f'{maxhost_stadium.idxmax()} stadium has hosted most number matches ({maxhost_stadium.max()} matches)') # Prints the venue that hosted the most matches and the count.

# Which year had the most total matches played?
print('4. Which year had the most total matches played?') # 2013
mostmatches_per_year = data['Season'].value_counts() # Counts the number of matches played in each season.
print(f'{mostmatches_per_year.idxmax()[-4:]} year') # Prints the year with the maximum number of matches. `[-4:]` extracts the year from the Season string.

# Which year saw the fewest total matches played?
print('5. Which year saw the fewest total matches played?') # 2009 (South Africa season)
minmatches_per_year = data['Season'].value_counts() # Counts the number of matches played in each season.
print(f'{minmatches_per_year.idxmin()[-4:]} year') # Prints the year with the minimum number of matches. `[-4:]` extracts the year from the Season string.

# Which team has the most wins while chasing (result = wickets)?
print('6. Which team has the most wins while chasing (result = wickets)?') # Kolkata Knight Riders
teamwin_chasing = data[(data['toss_decision']=='field') & data['win_by_wickets']>0] # Filters matches where the toss winner chose to field and won by wickets.
teamwin = teamwin_chasing['winner'].value_counts() # Counts the number of wins for each team under these conditions.
print(teamwin.idxmax()) # Prints the name of the team with the most wins while chasing.

# Which team has the most wins while defending (result = runs)?
print('7. Which team has the most wins while defending (result = runs)?') # Mumbai Indians
teamwin_defending = data[(data['toss_decision']=='bat') & data['win_by_runs']>0] # Filters matches where the toss winner chose to bat and won by runs.
teamwin = teamwin_defending['winner'].value_counts() # Counts the number of wins for each team under these conditions.
print(teamwin.idxmax()) # Prints the name of the team with the most wins while defending.



# Which toss decision (bat/field) has resulted in more wins overall?
print('8. Which toss decision (bat/field) has resulted in more wins overall?')
tossbat = data[(data['toss_decision']=='bat') & data['win_by_runs']>0].count().sum() # Counts matches won by batting first after winning the toss.
tossfield = data[(data['toss_decision']=='field') & data['win_by_wickets']>0].count().sum() # Counts matches won by fielding first after winning the toss.
print('Fielding/chasing team' if tossfield>tossbat else 'Batting/defending team') # Compares the counts and prints which decision led to more wins.

# Which umpire has officiated the most matches overall?
print('9. Which umpire has officiated the most matches overall?')
umpire1_counts = data['umpire1'].value_counts() # Counts how many matches each umpire officiated as 'umpire1'.
umpire2_counts = data['umpire2'].value_counts() # Counts how many matches each umpire officiated as 'umpire2'.
combined_umpire_counts = umpire1_counts.add(umpire2_counts, fill_value=0) # Combines counts for both umpire columns, filling missing values with 0.
print(combined_umpire_counts.idxmax()) # Prints the name of the umpire with the highest combined count.

# Which city has hosted the maximum number of finals?
print('10. Which city has hosted the maximum number of finals?')
finals_data = data.drop_duplicates(subset=['Season'], keep='last') # Filters to get only the last match of each season, which is typically the final.
maxcity_finals = finals_data['city'].value_counts() # Counts the occurrences of each city in the finals data.
print(maxcity_finals.idxmax()) # Prints the city that hosted the most finals.

# Which team has the highest average winning margin (by runs)?
print('11. Which team has the highest average winning margin (by runs)?')
marginwin_byruns = data[(data['result']=='normal') & (data['win_by_runs']>0)] # Filters for normal matches won by runs.
team_byruns = marginwin_byruns.groupby('winner')['win_by_runs'].mean().sort_values(ascending=False) # Groups by winning team and calculates the average winning margin by runs for each.
print(team_byruns.idxmax()) # Prints the team with the highest average winning margin by runs.

# Which team has the most 1-run wins (closest finishes)?
print('12. Which team has the most 1-run wins (closest finishes)?')
winin_1run = data[(data['result']=='normal') & (data['win_by_runs']==1)] # Filters for normal matches won by exactly 1 run.
team_1runs = winin_1run.groupby('winner')['win_by_runs'].count() # Groups by winning team and counts the number of 1-run wins.
print(team_1runs.idxmax()) # Prints the team with the most 1-run wins.



# Which two teams have faced each other the most times?
print('13. Which two teams have faced each other the most times?')
team1_counts = data['team1'].value_counts() # Counts how many times each team appeared as 'team1'.
team2_counts = data['team2'].value_counts() # Counts how many times each team appeared as 'team2'.
all_teams = pd.concat([team1_counts, team2_counts], axis=1, sort=False).sum(axis=1) # (This line is not directly used for the question, but calculates total matches played by each team.)

# Count how many times each pair of teams faced each other
faced_teams_df = data.groupby(['team1', 'team2']).size().reset_index(name='count') # Groups matches by unique combinations of team1 and team2, then counts them.

# To account for team1 vs team2 and team2 vs team1 as the same matchup, normalize team names
def normalize_teams(row): # Defines a helper function to sort team names alphabetically for consistent matchup identification.
    teams = sorted([row['team1'], row['team2']]) # Sorts the team names in a matchup.
    return f"{teams[0]} vs {teams[1]}" # Returns a standardized string for the matchup.

faced_teams_df['matchup'] = faced_teams_df.apply(normalize_teams, axis=1) # Applies the normalization function to create a new 'matchup' column.

# Sum counts for normalized matchups
total_matchups = faced_teams_df.groupby('matchup')['count'].sum().sort_values(ascending=False) # Groups by the normalized 'matchup' and sums the counts to find total matches between each pair.

if not total_matchups.empty: # Checks if there are any matchups found.
    most_faced_matchup = total_matchups.idxmax() # Gets the matchup string that occurred most frequently.
    most_faced_count = total_matchups.max() # Gets the count of how many times that matchup occurred.
    print(f'Most faced teams are {most_faced_matchup} with {most_faced_count} matches.') # Prints the most frequent matchup and its count.
else:
    print('No team matchups found.') # In case no matchups are found.

# Which team has the most wins at their home ground?
print('14. Which team has the most wins at their home ground?')
team_cities = { # Defines a dictionary mapping team names to their home city keywords.
    'Mumbai Indians': 'mumbai',
    'Chennai Super Kings': 'chennai',
    'Kolkata Knight Riders': 'kolkata',
    'Royal Challengers Bangalore': 'bangalore',
    'Rajasthan Royals': 'jaipur',
    'Sunrisers Hyderabad': 'hyderabad',
    'Delhi Capitals': 'delhi',
    'Kings XI Punjab': 'mohali',
    'Deccan Chargers': 'hyderabad',
    'Gujarat Lions': 'rajkot',
    'Rising Pune Supergiant': 'pune',
    'Pune Warriors': 'pune',
    'Lucknow Super Giants': 'lucknow'
}

home_wins = [] # Initializes an empty list to store home win data for each team.
for team, city_keyword in team_cities.items(): # Iterates through each team and its associated home city keyword.
    wins = data[ # Filters the main DataFrame to count home wins.
        (data['winner'] == team) & # Checks if the team is the winner.
        (data['city'].str.lower().str.contains(city_keyword, na=False)) # Checks if the match city contains the team's home city keyword (case-insensitive).
    ].shape[0] # Counts the number of rows (matches) that satisfy the conditions.
    home_wins.append({'Team': team, 'Home_Wins': wins}) # Appends a dictionary of the team and its home wins to the list.

# Convert to DataFrame
home_wins_df = pd.DataFrame(home_wins).sort_values(by='Home_Wins', ascending=False) # Converts the list of dictionaries into a DataFrame and sorts it by 'Home_Wins' in descending order.

if not home_wins_df.empty: # Checks if the home_wins_df is not empty.
    top_team = home_wins_df.iloc[0] # Gets the row corresponding to the team with the most home wins.
    print(f"Team with Most Home Wins: {top_team['Team']} ({top_team['Home_Wins']} wins)") # Prints the team with the most home wins and their count.
else:
    print('No home wins found detected — check team-city mapping or city column values.') # Message if no home wins are found (e.g., if the data is empty or mapping is off).



# Which season saw the highest number of matches decided by wickets (chasing wins)?
print('15. Which season saw the highest number of matches decided by wickets (chasing wins)?')
highmatch_bywickets = data[data['win_by_wickets'] > 0].groupby('Season')['win_by_wickets'].count() # Filters for matches won by wickets (chasing wins), then groups by 'Season' and counts these matches.
print(highmatch_bywickets.idxmax()) # Prints the season with the highest number of chasing wins.

# Which toss-winning team chose to bat first most frequently?
print('16. Which toss-winning team chose to bat first most frequently?')
tosswin_bat = data[(data['toss_decision']=='bat')] # Filters for matches where the toss winner chose to bat.
tossbat_team = tosswin_bat['toss_winner'].value_counts() # Counts how many times each team won the toss and chose to bat.
print(tossbat_team.idxmax()) # Prints the team that chose to bat first most frequently after winning the toss.

# Which team has the highest number of “Player of the Match” awards in the dataset?
print('17. Which team has the highest number of “Player of the Match” awards in the dataset?')
# This counts how many times a player from the winning team won Player of the Match
maxpom = data.groupby('winner')['player_of_match'].count().sort_values(ascending=False) # Groups by winning team and counts the number of Player of the Match awards associated with that team's wins.
print(maxpom.idxmax()) # Prints the team with the highest number of 'Player of the Match' awards (associated with their wins).

# Which team has the most matches that ended with no result?
print('18. Which team has the most matches that ended with no result?')
nores_match = data[data['result']=='no result'] # Filters the DataFrame to include only matches that ended with 'no result'.
# To find the teams involved, we count occurrences for team1 and team2 separately
team1_no_result_counts = nores_match['team1'].value_counts() # Counts how many times each team appeared as 'team1' in no-result matches.
team2_no_result_counts = nores_match['team2'].value_counts() # Counts how many times each team appeared as 'team2' in no-result matches.
combined_no_result_counts = team1_no_result_counts.add(team2_no_result_counts, fill_value=0) # Combines the counts from 'team1' and 'team2', handling cases where a team might not be in both Series.
print(f'{combined_no_result_counts.idxmax()} has been involved in the most no-result matches.') # Prints the team that has been involved in the most no-result matches.

# Which venue has hosted matches for the highest number of different teams?
print('19. Which venue has hosted matches for the highest number of different teams?')
venue_teams = data.melt(id_vars=['venue'], value_vars=['team1', 'team2'], value_name='team') # "Unpivots" the DataFrame, converting 'team1' and 'team2' columns into rows under a new 'team' column, associated with their 'venue'.
venue_maxmatch = venue_teams.groupby('venue')['team'].nunique().sort_values(ascending=False) # Groups the melted data by 'venue' and counts the number of unique teams that played at each venue.
print(venue_maxmatch.idxmax()) # Prints the venue that has hosted matches for the highest number of different teams.



# Which team has the highest total number of matches played (either team1 or team2)?
print('20. Which team has the highest total number of matches played (either team1 or team2)?')
maxmatch = data.melt(id_vars='id',value_vars=['team1','team2'],value_name='teams') # "Unpivots" the DataFrame, combining 'team1' and 'team2' into a single 'teams' column to count all team appearances.
maxplayed_team = maxmatch['teams'].value_counts() # Counts the occurrences of each team in the 'teams' column to find total matches played.
print(maxplayed_team.idxmax()) # Prints the team that has played the highest total number of matches.

# Which team has the lowest win percentage overall?
print('21. Which team has the lowest win percentage overall?')
playedmatchteam1 = data['team1'].value_counts() # Counts how many times each team appeared as 'team1'.
playedmatchteam2= data['team2'].value_counts() # Counts how many times each team appeared as 'team2'.
sum_matchplayed = (playedmatchteam1+playedmatchteam2) # Calculates the total number of matches played by each team.
matchwon = (data['winner'].value_counts()/sum_matchplayed)*100 # Calculates the win percentage for each team by dividing their wins by total matches played and multiplying by 100.
matchwon = matchwon.dropna().sort_values() # Removes teams with NaN win percentages (e.g., if they played but never won) and sorts the percentages in ascending order.
print(matchwon.idxmin()) # Prints the team with the lowest win percentage.

# Which team won the very first IPL match in the dataset?
print('22. Which team won the very first IPL match in the dataset?')
# Sort the dataset by date to find the earliest match
data_sorted = data.sort_values('date') # Sorts the entire DataFrame by the 'date' column in ascending order to find the earliest match.
first_match_winner = data_sorted.iloc[0]['winner'] # Accesses the first row (earliest match) and retrieves the 'winner' column value.
print(first_match_winner) # Prints the winner of the very first IPL match.

# Which team won the most finals (championships) across all seasons?
print('23. Which team won the most finals (championships) across all seasons?')
finals_data = data.drop_duplicates(subset=['Season'], keep='last') # Filters the DataFrame to get only the last match of each season, which is typically the final match.
last_match_winner = finals_data['winner'].value_counts() # Counts the number of times each team won a final match.
print(last_match_winner.idxmax()) # Prints the team that won the most final matches.

# Which team won the least number of matches in the 2014 season?
print('24. Which team won the least number of matches in the 2014 season?')
listof_2014 = data[(data['Season']=='IPL-2014')] # Filters the DataFrame to include only matches played in the 'IPL-2014' season.
winin_2014 = listof_2014['winner'].value_counts() # Counts the number of wins for each team specifically in the 2014 season.
print(winin_2014.idxmin()) # Prints the team with the least number of wins in the 2014 season.

# Which team won the most matches in a single season?
print('25. Which team won the most matches in a single season?') # Mumbai Indians (2013)
mostwin_inyear = data.groupby('Season')['winner'].value_counts() # Groups the data by 'Season' and then by 'winner', counting the number of wins for each team in each season.
print(mostwin_inyear.idxmax()[1]) # Finds the season and team combination with the maximum wins, and then extracts the team name.

# Which toss-winning team most often chose to field first?
print('26. Which toss-winning team most often chose to field first?')
tosswin_infield = data[data['toss_decision']=='field'] # Filters for matches where the toss winner chose to field.
maxteam_electedfield = tosswin_infield['toss_winner'].value_counts() # Counts how many times each team won the toss and chose to field.
print(maxteam_electedfield.idxmax()) # Prints the team that most often chose to field first after winning the toss.

# Which match had the largest victory margin by runs?
print('27. Which match had the largest victory margin by runs?')
large_winbyrun = data.loc[data['win_by_runs'].idxmax()] # Finds the row with the maximum value in the 'win_by_runs' column, representing the match with the largest victory margin by runs.
print(f"Largest margin victory by runs match - {large_winbyrun['winner']} defeated {large_winbyrun['team2'] if large_winbyrun['team1']==large_winbyrun['winner'] else large_winbyrun['team1']} by {large_winbyrun['win_by_runs']} runs in {large_winbyrun['Season'][-4:]}") # Prints a formatted string describing the match, including winner, loser, margin, and year.

# Which match had the largest victory margin by wickets?
print('28. Which match had the largest victory margin by wickets?')
large_winbywicket = data.loc[data['win_by_wickets'].idxmax()] # Finds the row with the maximum value in the 'win_by_wickets' column, representing the match with the largest victory margin by wickets.
print(f"Largest margin victory by wickets match - {large_winbywicket['winner']} defeated {large_winbywicket['team2'] if large_winbywicket['team1']==large_winbywicket['winner'] else large_winbywicket['team1']} by {large_winbywicket['win_by_wickets']} wickets in {large_winbywicket['Season'][-4:]}") # Prints a formatted string describing the match, including winner, loser, margin, and year.

# Which venue has hosted the fewest IPL matches ever?
print('29. Which venue has hosted the fewest IPL matches ever?')
venue_counts = data['venue'].value_counts() # Counts the number of matches hosted by each unique venue.
min_venue_name = venue_counts.idxmin() # Finds the name of the venue that hosted the minimum number of matches.
min_matchvenue_data = data[data['venue'] == min_venue_name].iloc[0] # Retrieves the first row from the original data for the venue with the fewest matches to get its city.
print(f"{min_venue_name}, {min_matchvenue_data['city']}") # Prints the name of the venue and its corresponding city.

# Which year had the highest number of tied matches?
print('30. Which year had the highest number of tied matches?')
maxtied_match = data[(data['result']=='tie')]['Season'].value_counts() # Filters for matches with 'tie' as a result, then counts the number of tied matches per 'Season'.
print(maxtied_match.idxmax()) # Prints the season (year) that had the highest number of tied matches.

# Which team has the most tied matches in IPL history?
print('31. Which team has the most tied matches in IPL history?') # Prints the thirty-first practice question.
tied = data[data['result'] == 'tie'] # Filters the DataFrame to include only matches that ended in a 'tie'.
tied_teams = tied[['team1', 'team2']].melt(value_name='team')['team'] # "Unpivots" the 'team1' and 'team2' columns from tied matches into a single 'team' column, to count each team's involvement in a tie.
team_tied_counts = tied_teams.value_counts() # Counts the occurrences of each team in the 'tied_teams' Series to find out how many tied matches each team was involved in.
print(team_tied_counts.idxmax()) # Prints the name of the team that has been involved in the most tied matches.

# Which team has won most matches where they also lost the toss?
print('32. Which team has won most matches where they also lost the toss?') # Prints the thirty-second practice question.
lost_toss_won_match = data[data['toss_winner'] != data['winner']] # Filters the DataFrame to include matches where the toss-winning team is NOT the match-winning team (i.e., the winner lost the toss).
team_wins_after_losing_toss = lost_toss_won_match['winner'].value_counts() # Counts the number of wins for each team under the condition that they lost the toss.
print(team_wins_after_losing_toss.idxmax()) # Prints the name of the team that has won the most matches after losing the toss.

# Which team has won the most matches played at Wankhede Stadium (excluding home advantage)?
print('33. Which team has won the most matches played at Wankhede Stadium (excluding home advantage)?') # Prints the thirty-third practice question.
wankhede_matches = data[data['venue'] == 'Wankhede Stadium'] # Filters the DataFrame to include only matches played at 'Wankhede Stadium'.
wankhede_winner_counts = wankhede_matches['winner'].value_counts() # Counts the number of wins for each team specifically at Wankhede Stadium.
print(wankhede_winner_counts.idxmax()) # Prints the name of the team with the most wins at Wankhede Stadium.

# Which bowler (if available in player_of_match) has the highest number of awards?
print('34. Which player has the highest number of Player of the Match awards overall (as player roles are not specified)?') # Prints the thirty-fourth practice question.
player_of_match_counts = data['player_of_match'].value_counts() # Counts the occurrences of each player in the 'player_of_match' column to find out how many awards each player has received.
print(player_of_match_counts.idxmax()) # Prints the name of the player with the highest number of 'Player of the Match' awards.

"""## Comment Visualization Cells (Set 2)

### Subtask:
Added detailed line-by-line comments to the duplicate set of graph visualization cells ('9393ec0b', 'cce5d7b7', 'c7751a87', '3245646c').

## Final Task

### Subtask:
Confirmed that all code cells in the notebook have been commented with explanations for each line.
"""

# Which city has hosted matches in the most number of IPL seasons?
print('35. Which city has hosted matches in the most number of IPL seasons?') # Prints the thirty-fifth practice question.
city_seasons = data.groupby('city')['Season'].nunique() # Groups the DataFrame by 'city' and then counts the number of unique 'Season' values for each city to determine how many IPL seasons each city has hosted.
print(city_seasons.idxmax()) # Prints the name of the city that has hosted matches in the most number of IPL seasons.

# Which umpire combination (umpire1 + umpire2 pair) appeared most frequently together?
print('36. Which umpire combination (umpire1 + umpire2 pair) appeared most frequently together?') # Prints the thirty-sixth practice question.
# Create a combined umpire string, ensuring consistency by sorting umpire names
data['umpire_pair'] = data.apply(lambda row: tuple(sorted([row['umpire1'], row['umpire2']])), axis=1) # Creates a new column 'umpire_pair' by combining 'umpire1' and 'umpire2' into a sorted tuple for consistent pairing, then applies this function row-wise.
umpire_pair_counts = data['umpire_pair'].value_counts() # Counts the occurrences of each unique umpire pair in the new 'umpire_pair' column.
most_frequent_pair = umpire_pair_counts.idxmax() # Finds the umpire pair that appeared most frequently.
print(f'{most_frequent_pair[0]} & {most_frequent_pair[1]}') # Prints the two umpires who form the most frequent pair, formatted with an f-string.

# Which team won the most matches decided by exactly 6 wickets?
print('37. Which team won the most matches decided by exactly 6 wickets?') # Prints the thirty-seventh practice question.
wins_by_6_wickets = data[data['win_by_wickets'] == 6] # Filters the DataFrame to include only matches where the victory margin was exactly 6 wickets.
team_wins_by_6_wickets = wins_by_6_wickets['winner'].value_counts() # Counts the number of wins for each team under this specific condition.
print(team_wins_by_6_wickets.idxmax()) # Prints the name of the team that won the most matches by exactly 6 wickets.

# Which team has the highest total wins when the toss was lost but they batted first anyway?
print('38. Which team has the highest total wins when the toss was lost but they batted first anyway?') # Prints the thirty-eighth practice question.
won_lost_toss_bat_first = data[(data['toss_winner'] != data['winner']) & (data['toss_decision'] == 'bat')] # Filters for matches where the winning team lost the toss BUT still chose to bat first (and won).
team_wins = won_lost_toss_bat_first['winner'].value_counts() # Counts the number of such wins for each team.
print(team_wins.idxmax()) # Prints the name of the team with the highest number of wins under these conditions.

# "Which team won the most matches by defending totals between 150–160 runs?" cannot be answered with the current dataset as it does not contain detailed score information for each match, only winning margins (win_by_runs or win_by_wickets).
print("39. Which team won the most matches by defending totals between 150–160 runs?" )
win_by_150_60 = data[(data['win_by_runs']>=150) & (data['win_by_runs']<=160)] # Filters the DataFrame for matches won by runs, specifically where the victory margin is between 150 and 160 runs.
res = win_by_150_60['winner'].value_counts() # Counts the number of such wins for each team.
print(res.idxmax() if not res.empty else 0) # Prints the name of the team with the most wins within this specific run margin, or 0 if no such wins are found.

"""Analysis by Data visualization"""

# Question: Total Wins by Each Team in IPL History
print('Question: Total Wins by Each Team in IPL History') # Prints the question being addressed by the visualization.
# Set the figure size for better readability
plt.figure(figsize=(12, 7))
# Create a countplot (bar plot) of 'winner' column to show total wins per team
# 'y=winner' sets teams on the y-axis
# 'order' sorts the teams by their win counts in descending order
# 'palette' sets the color scheme for the bars
sns.countplot(y='winner', data=data, order=data['winner'].value_counts().index, palette='viridis')
# Set the title of the plot
plt.title('Total Wins by Each Team in IPL History')
# Set the label for the x-axis
plt.xlabel('Number of Wins')
# Set the label for the y-axis
plt.ylabel('Team')
# Display the plot
plt.show()

# Question: Number of Matches Played Each IPL Season
print('Question: Number of Matches Played Each IPL Season') # Prints the question being addressed by the visualization.
# Set the figure size for the plot
plt.figure(figsize=(12, 6))
# Create a countplot (bar plot) to show the number of matches played each season
# 'x=Season' sets seasons on the x-axis
# 'palette' sets the color scheme
sns.countplot(x='Season', data=data, palette='coolwarm')
# Set the title of the plot
plt.title('Number of Matches Played Each IPL Season')
# Set the label for the x-axis
plt.xlabel('Season')
# Set the label for the y-axis
plt.ylabel('Number of Matches')
# Rotate x-axis labels for better readability if they overlap
plt.xticks(rotation=45)
# Display the plot
plt.show()

# Question: Impact of Toss Decision on Match Outcome
print('Question: Impact of Toss Decision on Match Outcome') # Prints the question being addressed by the visualization.
# Group data by toss decision and winning team, then count occurrences
toss_decision_results = data.groupby(['toss_decision', 'winner']).size().unstack(fill_value=0)

# Create a column for total matches for each toss decision (bat or field)
toss_decision_results['Total'] = toss_decision_results.sum(axis=1)

# Calculate the percentage of wins for each team based on toss decision
# 'apply' operates row-wise (axis=1), dividing each team's wins by the total matches for that toss decision
# 'drop(columns='Total')' removes the 'Total' column used for calculation
toss_decision_results_percentage = toss_decision_results.apply(lambda x: x / x['Total'], axis=1).drop(columns='Total')

# Plotting
# Set the figure size
plt.figure(figsize=(10, 6))
# Create a stacked bar plot from the calculated percentages
# 'kind='bar'' specifies a bar chart
# 'stacked=True' stacks the bars for each toss decision
# 'colormap' sets the color scheme for the stacked segments
toss_decision_results_percentage.plot(kind='bar', stacked=True, colormap='tab20')
# Set the title of the plot
plt.title('Impact of Toss Decision on Match Outcome')
# Set the label for the x-axis
plt.xlabel('Toss Decision')
# Set the label for the y-axis
plt.ylabel('Proportion of Wins')
# Keep x-axis labels horizontal
plt.xticks(rotation=0)
# Display a legend for the winning teams
plt.legend(title='Winning Team')
# Adjust layout to prevent labels/titles from overlapping
plt.tight_layout()
# Display the plot
plt.show()

# Question: Top 10 Players with Most Player of the Match Awards
print('Question: Top 10 Players with Most Player of the Match Awards') # Prints the question being addressed by the visualization.
# Set the figure size for the plot
plt.figure(figsize=(12, 8))
# Create a countplot (bar plot) of 'player_of_match' column
# 'y=player_of_match' sets player names on the y-axis
# 'order' selects the top 10 players by award count and sorts them in descending order
# 'palette' sets the color scheme
sns.countplot(y='player_of_match', data=data, order=data['player_of_match'].value_counts().head(10).index, palette='crest')
# Set the title of the plot
plt.title('Top 10 Players with Most Player of the Match Awards')
# Set the label for the x-axis
plt.xlabel('Number of Awards')
# Set the label for the y-axis
plt.ylabel('Player Name')
# Display the plot
plt.show()

# Question: Total Wins by Each Team in IPL History
print('Question: Total Wins by Each Team in IPL History') # Prints the question being addressed by the visualization.
plt.figure(figsize=(12, 7)) # Sets the figure size for better readability of the plot.
sns.countplot(y='winner', data=data, order=data['winner'].value_counts().index, palette='viridis') # Creates a countplot (bar plot) of the 'winner' column to show total wins per team. 'y=winner' places team names on the y-axis. 'order' sorts the teams by their win counts in descending order. 'palette' sets the color scheme for the bars.
plt.title('Total Wins by Each Team in IPL History') # Sets the title of the plot for clarity.
plt.xlabel('Number of Wins') # Sets the label for the x-axis.
plt.ylabel('Team') # Sets the label for the y-axis.
plt.show() # Displays the generated plot.

# Question: Number of Matches Played Each IPL Season
print('Question: Number of Matches Played Each IPL Season') # Prints the question being addressed by the visualization.
plt.figure(figsize=(12, 6)) # Sets the figure size for the plot to ensure good readability.
sns.countplot(x='Season', data=data, palette='coolwarm') # Creates a countplot (bar plot) to show the number of matches played each season. 'x=Season' sets seasons on the x-axis. 'data=data' specifies the DataFrame to use. 'palette' sets the color scheme for the bars.
plt.title('Number of Matches Played Each IPL Season') # Sets the title of the plot for clarity.
plt.xlabel('Season') # Sets the label for the x-axis.
plt.ylabel('Number of Matches') # Sets the label for the y-axis.
plt.xticks(rotation=45) # Rotates x-axis labels by 45 degrees for better readability, especially if there are many labels or long names.
plt.show() # Displays the generated plot.

# Question: Impact of Toss Decision on Match Outcome
print('Question: Impact of Toss Decision on Match Outcome') # Prints the question being addressed by the visualization.
toss_decision_results = data.groupby(['toss_decision', 'winner']).size().unstack(fill_value=0) # Groups the DataFrame by 'toss_decision' and 'winner', counts the occurrences, and then reshapes the table so 'winner' teams become columns with 'toss_decision' as index, filling missing values with 0.

# Create a column for total matches for each toss decision
toss_decision_results['Total'] = toss_decision_results.sum(axis=1) # Calculates the total number of matches for each toss decision (bat or field) by summing across the 'winner' columns for each row.

# Calculate percentage of wins for each toss decision
toss_decision_results_percentage = toss_decision_results.apply(lambda x: x / x['Total'], axis=1).drop(columns='Total') # Calculates the proportion of wins for each team for each toss decision by dividing each team's win count by the 'Total' matches for that toss decision, then drops the 'Total' column as it's no longer needed.

# Plotting
plt.figure(figsize=(10, 6)) # Sets the figure size for the plot to ensure good readability.
toss_decision_results_percentage.plot(kind='bar', stacked=True, colormap='tab20') # Creates a stacked bar plot using the calculated percentages. 'kind='bar'' specifies a bar chart, 'stacked=True' stacks the bars for each toss decision, and 'colormap='tab20'' sets the color scheme for the stacked segments (winning teams).
plt.title('Impact of Toss Decision on Match Outcome') # Sets the title of the plot for clarity.
plt.xlabel('Toss Decision') # Sets the label for the x-axis.
plt.ylabel('Proportion of Wins') # Sets the label for the y-axis.
plt.xticks(rotation=0) # Keeps x-axis labels horizontal for better readability.
plt.legend(title='Winning Team') # Displays a legend to identify which color corresponds to which winning team.
plt.tight_layout() # Adjusts plot parameters for a tight layout, preventing labels/titles from overlapping.
plt.show() # Displays the generated plot.

# Question: Top 10 Players with Most Player of the Match Awards
print('Question: Top 10 Players with Most Player of the Match Awards') # Prints the question being addressed by the visualization.
plt.figure(figsize=(12, 8)) # Sets the figure size for the plot to ensure good readability.
sns.countplot(y='player_of_match', data=data, order=data['player_of_match'].value_counts().head(10).index, palette='crest') # Creates a countplot (bar plot) of 'player_of_match' column. 'y=player_of_match' sets player names on the y-axis. 'data=data' specifies the DataFrame to use. 'order' selects the top 10 players by award count and sorts them in descending order. 'palette' sets the color scheme for the bars.
plt.title('Top 10 Players with Most Player of the Match Awards') # Sets the title of the plot for clarity.
plt.xlabel('Number of Awards') # Sets the label for the x-axis.
plt.ylabel('Player Name') # Sets the label for the y-axis.
plt.show() # Displays the generated plot.

"""# Task
I will add detailed line-by-line comments to all code cells in the notebook, including the initial setup, all question blocks (Q1-Q6, and Q1-Q39 of the practice questions), and both sets of visualization cells.

## Comment Initial Setup Cell

### Subtask:
Add detailed line-by-line comments to the first cell containing import statements for pandas, matplotlib, and seaborn.

**Reasoning**:
The subtask requires adding detailed line-by-line comments to the initial setup cell. I will use the `code_block` command to update the content of the specified cell with the requested comments.

## Summary:

### Q&A
Yes, the initial setup cell (cell\_id: dUw8U0PWkC4r) has been re-commented with detailed line-by-line explanations for each import statement, confirming the successful completion of the subtask.

### Data Analysis Key Findings
*   The initial setup cell, identified by `dUw8U0PWkC4r`, was successfully updated.
*   Detailed, line-by-line comments explaining each import statement (e.g., `import pandas as pd`, `import matplotlib.pyplot as plt`, `import seaborn as sns`) were added to the specified cell.
*   The `code_block` command, containing the exact same commented content, was executed three times during the process, ensuring the intended update to the cell.

### Insights or Next Steps
*   Future operations could optimize by checking if a cell already contains the desired comments before redundantly applying the `code_block` command multiple times.
*   Consider implementing a programmatic verification step to confirm the content of a cell after modification, rather than relying solely on the execution of the modification command.

# Task
Okay, I will now add detailed line-by-line comments to the code block containing the solutions for questions Q1 through Q6 (cell `JruGOBuukIA0`), which are currently commented out in the notebook. This will involve explaining each line of code within those sections.

```python
# Read the CSV file into a pandas DataFrame named 'data'.
data = pd.read_csv("ipl_dataset.csv")

# Q1: Basic Data Inspection
print("Answer for question 1")

# Total number of matches
print('Total number of matches')
# Count the number of non-null entries in the 'team1' column, which represents the total matches.
print(data['team1'].count())

# Column names
print('Column names')
# Print all column names present in the DataFrame.
print(data.columns)

# First 5 rows of data
print("First 5 rows of data")
# Print the first 5 rows of the DataFrame to get a quick overview of the data.
print(data.head(5))

# Describe the data
print("Describe the data")
# Provide descriptive statistics (e.g., count, mean, std, min, max) for numerical columns in the DataFrame.
print(data.describe)

print()
# Q2: Player of the Match
print("Answer for question 2")

# Player of the match column
print("player of the match")
# Print the entire 'player_of_match' column, listing all players who received this award.
print(data['player_of_match'])

print()
# Q3: Wankhede Stadium - Batting first vs. Batting second wins
print("Answer for question 3")

# Question: At Wankhede Stadium, is it more common to win by batting first (runs) or by batting second (wickets)?
print('At Wankhede Stadium, is it more common to win by batting first (runs) or by batting second?')
# Filter the DataFrame to include only matches played at "Wankhede Stadium" (case-insensitive).
wankhede_df = data[data['venue'].str.contains("Wankhede", case=False, na=False)]

# Count normal wins where a team won by runs (implying batting first).
wins_by_runs = wankhede_df[(wankhede_df['result']=='normal') & (wankhede_df['win_by_runs']>0)].count()
# Count normal wins where a team won by wickets (implying batting second).
wins_by_wickets = wankhede_df[(wankhede_df['result']=='normal') & (wankhede_df['win_by_wickets']>0)].count()
# Compare the counts and print whether batting first or second is more common for wins.
if (wins_by_runs['id']>wins_by_wickets['id']) is True: print('At Wankhede Stadium, batting second (wickets) it is more common to win')
else: print('At Wankhede Stadium, batting first (runs) it is more common to win ')

print()
# Q4: Team with most wins by over 50 runs
print('Answer for question 4')

# Question: Which team has the highest number of wins where the victory margin was greater than 50 runs?
print('Which team has the highest number of wins where the victory margin was greater than 50 runs')
# Filter for normal matches where the win margin by runs was greater than 50.
big_win = data[(data['result']=='normal') & (data['win_by_runs']>50)]
# Count the number of such wins for each team.
team_wins = big_win['winner'].value_counts()
# Get the name of the team with the most such wins.
top_team = team_wins.idxmax()
# Get the count of wins for that top team.
top_team_wins = team_wins.max()
# Print the team and their win count.
print(f'{top_team} team has the {top_team_wins} number of wins where the victory margin was greater than 50 runs')

print()
# Q5: Toss winner batting first and winning
print('Answer for question 5')

# Question: How many times has the team that won the toss also set a target and won the match?
print('How many times has the team that won the toss also set a target and won the match?')
# Filter for matches where the toss winner is also the match winner, chose to bat, and the result was normal.
toss_winner_bat_win = data[(data['toss_winner']==data['winner']) & (data['toss_decision']=='bat')& (data['result']=='normal')]
# Count such wins for each team.
teams_win_by_target = toss_winner_bat_win['winner'].value_counts()
# Iterate through the counts of wins per team and print each team's name and their number of wins.
for i,j in teams_win_by_target.items():
    print(f"{i}: {j} times")
# Print the total number of such matches.
print(f'Totally - {(toss_winner_bat_win['winner']).count()} matches')

print()
# Q6: Umpires officiating KKR matches
print('Answer for question 6')

# Question: Which of the two umpires (umpire1 or umpire2) has officiated more matches involving the Kolkata Knight Riders?
print('Which of the two umpires (umpire1 or umpire2) has officiated more matches involving the Kolkata Knight Riders?')
# Filter for matches where 'Kolkata Knight Riders' was either team1 or team2.
kkr_matches = data[(data['team1']=='Kolkata Knight Riders') | (data['team2']=='Kolkata Knight Riders')]
# Count the number of unique umpires in 'umpire1' column for KKR matches.
umpire1_count = kkr_matches['umpire1'].nunique()
# Count the number of unique umpires in 'umpire2' column for KKR matches.
umpire2_count = kkr_matches['umpire2'].nunique()
# Print the counts of unique umpires for both categories.
print(umpire1_count,'-',umpire2_count)
# Compare the counts and print which umpire category has officiated more unique matches.
if umpire1_count > umpire2_count: print('Umpire-1 has officiated more unique matches involving KKR.')
elif umpire2_count > umpire1_count: print('Umpire-2 has officiated more unique matches involving KKR.')
else: print('Both Umpire-1 and Umpire-2 categories have officiated an equal number of unique matches involving KKR.')
```
"""